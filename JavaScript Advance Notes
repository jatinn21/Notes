Javascript : 

remember that in execution context, we have three things :
Variable environment
Scope Chain
This keyword

ch : 94 :  Hoisting
make some types of variable accessible/usable in the code before they are actually declared. 
BTS : at the back before the execution, code is scanned for variable declaration, and for each variable, a new property is created in the variable environment object.
This is how hoisting works

function declaration :  Yes, It can be hoisted. 
                                    Initial value willl be the actual function 
                                    scope : block

var variables :  Yes, It can be hoisted. 
                                    Initial value willl be the undefined
                                    scope : function

let and const :  nope, It can be hoisted technically but not in practice. 
                                    Initial value willl be the <uninitialized> / TDZ (Temporal Dead Zone)
                                    scope : block

function expression & arrows : depends if we are using var, or const / let


Temporal Dead Zone : if(myName === 'Jonas'){
console.log(`Jatin is a ${job}`);              ----------------> used before declared // referecne error cannot access 'job' before initialization bc job is declared using const ----> TDZ
const age = 2027-1979;                       --------------------------------------------------------------------> TDZ
const job = 'teacher';                            -----------------------> here it's called so all above will be TDZ
console.log(x);                                       -------------------> different error : referecence error : x is not defined
}




ch : 95 :  This keyword
special keyword that is created for every function. 

const jatin = {
   name : 'Jatin',
   year  :  1989,
   calcAge : function (){                    -----------------> where calcAge is a method
        return 2037 - this.year;           ------------------> this = jatin object ; this.year = 1989
   }
}

jonas.calcAge() -----> 48

how we can call this : 
i. Method  : this  = <object that is calling the method> 
ii. Simple function call : this = undefined (talking about strict mode else it would target window object)
iii.  Arrow functions  : this  = < this of the surrounding function (parents this keyword as arrow function don't have there own this keyword)
iv.  Event listener :  this  = <DOM element that the handler is attached to >

this does not point to the function itself

this keyword in global target window object : 
console.log(this) -------------------> window object

this keyword inside an function declaration/expression gives us undefined: 
const calcAge = function(birthYear){
console.log(2023-birthYear);  -----------------> 22
console.log(this); --------------------> undefined   
}
calcAge(2001)

this keyword inside an Arrow function gives us this keyword of their parent as Arrow functions don't have there own this keyword :
const calcAge2 = birthYear =>{
console.log(2023-birthYear);  -----------------> 22
console.log(this); --------------------> window object as the parent of the this arrow function will be global scope.
} 

this keyword inside an object's method gives us the object whose method has called it.
const jatin = {
year : 1991,
calcAge : function(){
console.log(this);    -----------------> { year :1991, calcAge : f }
          }
  }
jatin.calcAge()
 --------------------------------------------
const matilda = {
  year : 2001 
}  

// Method Borrowing following DRY principle
matilda.calcAge = jatin.calcAge;  // now both object has calcAge method 
matilda.calcAge()  //---> here the this keyword will be matilda so  { year :2001, calcAge : f }

const func = jatin.calcAge;  // ------> so now func is now function that will print console.log(this)
func()  //--------> undefined because this keyword value inside a regular function is undefined


Day : 1
Remember that variable made with "var" are saved in Global Window Object
Also don't use arrow function as object's methods

This keyword inside an Object Method -> Function :
const Jatin = {
      firstName : 'Jatin',
      year : 2001,
      calcAge : function(){
              console.log(this) ------------------------> Object that is calling this like 'Jatin' 
              console.log(this.year)  -------------------> 2001
// Creating a function and calling it inside the method
                
               const isMillenial = function(){ -------------------------> Normal Function
                          console.log(this);  -------------------------------> Undefined 
                          console.log(this.year>=1981 && this.year<=1996);  -------------> undefined.year will be an Typeerror
                 }
                isMillenial() 
        }
}


So that will throw an error So how can we solve this ?
Solution 1 : using variable = this
Ans. We can create a variable that will be assigned to this and can use it inside the isMillenial function. When we will say variable.year where that variable is not present inside the isMillenial function, it will search that in parent scope where it's defined as object : 

const Jatin = {
      firstName : 'Jatin',
      year : 2001,
      calcAge : function(){
              console.log(this) ------------------------> Object that is calling this like 'Jatin' 
              console.log(this.year)  -------------------> 2001
              let self = this; ------------------------> here we have assigned self to this and use it inside isMillenial()
 // Creating a function and calling it inside the method                
               const isMillenial = function(){ -------------------------> Normal Function
                          console.log(self);  -------------------------------> goes into parent scope where this = Object
                          console.log(self.year>=1981 && self.year<=1996);  -------------> false
                 }
                isMillenial() 
        }
}

Solution 2 : using arrow function as it get their parent's this 
const Jatin = {
      firstName : 'Jatin',
      year : 2001,
      calcAge : function(){
              console.log(this) ------------------------> Object that is calling this like 'Jatin' 
              console.log(this.year)  -------------------> 2001
 // Making the function Arrow so it get the this keyword of its parent
               const isMillenial = ()=>{ -------------------------> Normal Function
                          console.log(this);  -------------------------------> goes into parent where this = Object
                          console.log(this.year>=1981 && this.year<=1996);  -------------> false
                 }
                isMillenial() 
        }
}




About Arguments keyword : there is more modern way to get n number of parameters in function but this also exist!!

a. Normal function : 

const addExpr = function(a,b){
         console.log(arguments)
        return a+b;
}

addExpr(2,5)  ----------------> console -> Arguments Object ->  [   0 : 2     1 : 5 ......   ]

// if we give more than required arguments then also there is no problem like
addExpr(2,5,6,8)   --------------->  console -> Arguments Object ->  [   0 : 2     1 : 5   2 : 6    3 : 8   ......   ]
Say thanks to arguments but this only works in regular/normal function 


b. Arrow Function :  
const addExpr = (a,b) => {
         console.log(arguments)
        return a+b;
}

addExpr(2,5)  ----------------> console -> reference Error: arguments not defined







// Primitives && Non-primitives 
Primitive Data types : Number, String, Boolean, Undefined, Null, BigInt && Symbol            ----------> primitive types
Everything else is an Object  Like : Array, functions, Object          ---------------------------------------> reference types 

names are kept because of the different way in which they are stored in memory ,

In Primitive : 
let age = 30;
let oldAge = age;
age=31
console.log(age)   ----------------------> 31   (Simple)
console.log(oldAge) ---------------------> 30  (Simple)

In Non-Primitive :
const me = {
     name : 'Jatin',
     age : 10
}

const friend = me
friend.age = 20
console.log( friend ) ----------------------> { name : 'Jatin' , age : 20 }    ------> Ok
console.log( me )  -------------------------> { name : 'Jatin' , age : 20 }   ------> Strange as we have changed for friend object only


We have to keep remember about JavaScript engine ;
It has two components : callstack --> Where functions are executed and to heap where objects are stored in memory (only for reference types)
Primitives types are stored in callstack
Reference types are stored in heap


/*
let age = 30;
let oldAge = age;
age=31
console.log(age)   ----------------------> 31   (Simple)
console.log(oldAge) ---------------------> 30  (Simple)

So here age -> 0001 -> value -> 30 
            OldAge -> 0002 -> value -> 0001 ->value ---> 30
              age -> 0001 -> value changed -> 31

Solved issue 1
*/



/*
const me = {
     name : 'Jatin',
     age : 10
}

const friend = me
friend.age = 20



In heap  

   Address -> D30F , Value ->  {  name : 'Jatin' , age : 10 } 



in callstack

    Identifier -> me ,  Address -> 0004 , Value  -> D30F (reference to memory address in heap)


   When we declare a variable as an object, an identifer is created, which points to a piece of memory in the stack which in turn points to a peice of memory in the heap and that is where the object is actually stored this is because objct can be too large to be stored in the stack. Instead they are stored in the heap, which is like an almost unlimited memory pool and the stack just keeps a reference to where the object is actually stored in the heap so that it can find it whenever it's necessary 

So now we creates a new object "Friend" , a new identifier will be created with "friend" name and it will point to the same address
 It won't create a new object in the heap. It's simply just another varibale in the stack which holds the reference to the original object.
So both of the two objects are pointing to the same memory address in the heap because in the stack they both hold the same memory address reference

    Identifier -> Friend ,  Address -> 0004 , Value  -> D30F (reference to memory address in heap)
   So it's exactly the same object "me" but with different identifier name sharing same memory "D30F"
    


So here me -> 0001 -> value -> { name : 'Jatin',   age : 10 }                      ->  { name : 'Jatin',   age : 20 } 
            friend -> me -> 0001 -> value ->  { name : 'Jatin',   age : 10 }       |
              friend.age  -> 0001 -> age -> 10 --> age -> 20  -----------------|

Solved issue 2
*/





Object.assign()  : Only upto one level,

What if we want changes in one object should not reflect the other object ?
For that we can use of Object.assign : this merge two objects and return the new one

const khushi ={
 firstName : 'Khushi',
 lastName  : 'Maheshwari'
 family : ['darshan','manoj']
}

const marriedKhushi = Object.assign( {} , khushi ); ---------> this will merge a empty object and khushi object so that all the properties/methods are copied and stored in a new object "marriedKhushi" in the heap


marriedKhushi.lastName = 'Joshi'
//So it will only effect the marriedKhushi and not khushi

Note ---->Goes upto one level only, means if there is an object inside an object it might not work as we want. We want Deep clone and not a shallow copy. For example there is an 'family' Array (Object) inside the 'khushi' object and that will be copied to both two objects : khushi and marriedKhushi. So far so good. 
But if there is change in marriedKhushi like the family increases : 

marriedKhushi.family.push('yashu');
marriedKhushi.family.push('pushpa');

This will effect in both the object as now both will show family with 4 elements.
So that is not what we want

We want a deep clone later............









Destructing Array

const arr = [2,13,5]
const [x,y,z] = arr;
x -> 2 , y -> 13,  z-> 5

const categories =  ['pizza','burger','pasta','roll','fries'];
const [first,second] = categories
first -> pizza, second -> burger

const [first, , second] = categories   -----> skipped the second element
first -> pizza, second -> pasta




#Swapping 
first = pizza ; second = pasta 
first = pasta; second = pizza

How?
const categories =  ['pizza','burger','pasta','roll','fries'];
let [ first, second ] = categories
[ first, second ] = [ second , first ]


#Nested Destructing
const arr = [ 5 , 6 , [ 8 , 9 ] ]
const [ a ,  , [ b , c ]  ] = arr 
a -> 5, b -> 8 , c -> 9


#More than have : undefined 
const arr = [ 4 , 5 ]
const [ a , b , c ]  = arr
a  -> 4, b -> 5 , c -> undefined


#Set Default value
const arr = [ 4  ]
const [ a=1 , b=1 , c=1 ]  = arr
a  -> 4, b -> 1 , c -> 1








Destructing Object
you have to use the same property name as mentioned in the object
Here the order doesn't matter 

let hotel = {
  name : "sarvottam",
  categories : ["Italian","Pizzeria","Vegetarian","Garlic Bread"],
  mainMenu : ["Pizza","Pasta","Risotto"],
  openingHours : {
                   thr : { open : 12 , close : 22 },
                   fri  : { open : 11 , close : 23 },
                   sat : { open : 0 , close : 24 },
              },
  order : function (starterIndex,mainIndex){
              return [this.starterMenu[starterIndex] , this.mainMenu[mainIndex] ]   
     },
};

const {name ,openingHours,categories} = hotel;    --------> order is not there but it's works



#If you want a new name to be used : 
const {name : hotelName, openingHours : hours, categories : tags} = hotel;


# to set a default value i the object , Same as in Array
const { menu = [] , starterMenu : starters = [] } = hotel;
as starterMenu is already there in the hotel object so empty array won't be assigned but menu will be created which is an array with empty value.


# to mutate the existing variable and reassigned there values using the object properties
let a =111;
let b = 999;
const obj = { a : 23 , b : 7 , c : 14 };
( { a , b  } = obj  ); ----------------------> now a = 23 and b  = 7


#Nested Object : inside hotel, there is an openingHours Object and inside that we have more objects like thru,fri, sat.which has open and close info.

let destruct that : 

let { openingHours } = hotel;
let { fri } = openingHours  ----------------> ok no problem
let { fri : { open , close } }  = openingHours  ;  -----------> open  = 11, close  = 23

We can change the name also  : 
let { fri : { open : OP , close : CL } }  = openingHours  ; 




# Where to use this : Example 
 
let hotel = {
  name : "sarvottam",
  categories : ["Italian","Pizzeria","Vegetarian","Garlic Bread"],
  mainMenu : ["Pizza","Pasta","Risotto", "Burger" , "Manchurain"],
  openingHours : {
                   thr : { open : 12 , close : 22 },
                   fri  : { open : 11 , close : 23 },
                   sat : { open : 0 , close : 24 },
              },
  order : function (starterIndex,mainIndex){
              return [this.starterMenu[starterIndex] , this.mainMenu[mainIndex] ]   
     },

  orderDelivery : function ( { orderDeliveryTime= "23: 40" ,orderAddress ,mainIndex = 0   } )    --------------------------------------------> Here we have destructred the Object
  { 
      console.log (` Order Delivered!!  Your order : ${ this.mainMenu[ mainIndex ] }   is sent to the address : ${ orderAddress } , Expected Delivery Time :   ${ orderDeliveryTime }. `);
  }
};


  hotel.orderDelivery( {  orderDeliveryTime : " 24 : 00 " ,  orderAddress  : " Vatika Town Ship, Parvat Patia, Surat " , mainIndex : 3  }  )  -----------------> 
O/P : Order Delivered!!  Your order : Burger  is sent to the address :  Vatika Town Ship, Parvat Patia, Surat, Expected Delivery Time :  24 : 00  . 

  hotel.orderDelivery( {,  orderAddress  : " Vatika Town Ship, Parvat Patia, Surat "  )  -----------------> 
O/P : Order Delivered!!  Your order : Pizza is sent to the address :  Vatika Town Ship, Parvat Patia, Surat, Expected Delivery Time :  23 : 40  . 








# Spread Operator :

let arr = [ 1 , 2 , 3 ];
let newArr = [  4 , 5 , 6 , . . . arr ]  ------------------->  [ 4 , 5 , 6 , 1 , 2 , 3 ];

console.log( . . . newArr )  --------------------------> 4  5  6  1  2  3 


# Real world Example : 
 let newMenu = [  . . . hotel.menu, ' Vadapav ' ,  '  Misalpav '  ];


Note  : Iterables are arrays, strings, sets, maps but not Objects

We can also spread a string in an array : 
 let name = "Jatin";
 let fullName = [ ' Mr. '  , ' ' ,  . . . name ]

Note :  you can't use spread operator inside an template literal :   ` $ {  . . . name }  ` 

You can alo use spread with objects
let newHotel = { foundedIn : 2001  ,  . . . hotel , Founder : 'Jatin'  }  --------->  to create a copy of an object with additional details
let hotelCopy = { . . . hotel }          ------------------------------------------> To create a copy of an Object
 





# Rest Pattern and Parameters : Opposite of Spread
Spread : to unpack an array
Rest  :  to pack elements into an array


Spread : Because it's on the Right side of the =
let arrWithSpread = [ 1, 2,  3 , . . . [ 5 , 6 , 7  ] ];


Rest : Because it's on the Left side of the =
let [  First , Second , . . . others ] = [ 1, 2,  3 , 5 , 6 , 7  ];  -----------> First  = 1 , Second = 2 , others = [  3 , 5 , 6 , 7 ]

let [ pizza ,  , risotto , . . . others  ]  =  [ . . . hotel.mainMenu , . . . hotel.starterMenu  ]         ---------------> it used unused element of destructing array/object so always  make the rest element as the last element 


 rest in Objects

let { sat , . . . weekdays }  = hotel.openingHours;  ------------------------>  sat  =  { open : 0 , close : 24 } , weekdays =  { thr : { open : 12 , close : 22 }, fri  : { open : 11 , close : 23 }}



# Where to use this rest pattern ? 
When you want arbitary number of paramters in a function ;like : 
add(  1, 3 )
add(  2 ,4, 8, 9, 10 )
add( 4, 6, 3, 3, 43, 53, 9) 

Here we are taking multiple values as an paramter and pack them into an array
function add ( . . . numbers  ){  console.log( numbers )   }  ----------------> [ 1 , 3 ]   ,  [ 2 ,4, 8, 9, 10 ] , [ 4, 6, 3, 3, 43, 53, 9 ]









#  Short Circuiting
In Or  = He will search for the truthyvalue , as as he got one he will return that unless we are going to get thee last element
In And  = He will search for the falsy value , as as he got one he will return that unless we are going to get thee last element


Falsy values = NaN , "" , undefined, null , 0  and false

console.log( 4 | |  ' Jatin '  )   ----------> 4 as 4 is a truthyvalue so it will immediately return that
console.log( 4 | |  ' Jatin '  )   ----------> 'Jatin' as there is no falsy value and this is the last element


Where to use ? 
instead of using ternary operator like this : 

let numGuests =  hotel.numGuests ? hotel.numGuests : 10;
console.log ( numGuests )   ;     -------------------------------------------> as hotel.numGuests is not there, we will get 10.

Using Short circuiting : 
let numGuests =  hotel.numGuests ||  10;  -------> if there is any true value in numGuest of the hotel it will be returned else 10 will be returned


Where to use ?? 
Instead of using : 
if( hotel.orderFood ){  hotel.orderFood( 'mushroom' , ' spinach'  ) };

use shortcircuting And because if it's false nothing will work if the value is true then only function will be called  : 
hotel.orderFood && hotel.orderFood( 'mushroom' , ' spinach'  );

Nullish coalescing operator ? ? : It removes 0 and  empty string ' '  from the falsy value and return the true value (including 0 and ' ' ) and it it didn't get one we will get the last element
 0 ? ?  true -------> 0
null ?? undefined ?? ' ' ?? 'true'  ---------> ' '
null ?? 0 ?? 'true'    ----------->  0






# Logical Assignment operator

let rest1 = {  name : ' Capri ' , numGuest : 20  } 
let rest1 = {  name : ' Pizaria ' , owner : ' Jatin Sharma '  }
instead of 
rest1.numGuest = rest1.numGuest || 10; 
rest2.numGuest = rest2.numGuest || 10; 
use this : 
rest1.numGuest  ||=  10;  --> if rest1 object doesn't have any numGuest then make 10 as default


rest2.owner = rest2.owner && "<Anonymous>";  ---------> if you want that if there is any owner attribute mentioned in the rest2 then make it to "Anonymous"
rest2.owner &&= "<Anonymous>";
 





------------------------------------------------------------> New Day


#Loops in Javascript

For of loop : 
const arr =  [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ]
for ( const item of arr ){  
    console.log( item )
  }

Note : To get the index, it's a bit of a pain but you can get it by this way:
for( const item of arr.entries() ) { 
       console.log(items)
  }

O/P :  [ 0 , 1  ] , [ 1 ,2 ], [ 3 , 4 ], [4 , 5] , [ 5 , 6 ]...

Now as we know that items.entries()  give us an array of arrays where each element is an array of two elements, i. index and ii. the content/value

so we can destructing it and use it : 
for( const [ i , value ] of arr.entries() ) { 
       console.log( `  ${ i+1 } : $ { value } ` );
  }










#Optional chaining : Important 
only if the property exist that is before the question mark then only after the question mark property will be read but if not then immediately undefined will be returned. and Exists here actually means the nullish concept, so a property exists if it's not null and not undefined so if it's zero or the empty string, then it still exists.

We know that inside the hotel there is an openinghours for thrus, fri & sat. If we tried for monday that doesn't exist then we will get undefined. and if we tried open property of it ( monday ) we will get an error. so to avoid that error we will use optional chaining :

console.log( hotel.openingHours.mon.open ) ----------> Type-error : cannot read property 'open' of undefined  
console.log( hotel.openingHours.mon?.open ) ----------> undefined
 
console.log( hotel.openingHours?.mon?.open ) ----------> if inside hotel, there is any property named openingHours, if yes then go further and check whether it has mon in it and if yes then go to open . in any case there is false statement like it doesn't exist then we wil get undefined.


Example : 
const days =   [  'mon' , 'tue' , 'wed' , 'thru' , 'fri' , 'sat' , 'sun'  ];
for ( const item of days ){
     const open = hotel.openingHours[ days ] ? . open  || ' closed '     ------> instead of showing undefined, it will show ' closed ' but now 0 will also count as  'falsy' value' 

      const open  = hotel.openingHours[ days ] ? . open ? ? ' closed '
     console.log( ` On $ { day }, we open at $ { open }  ` )
}
 


 Now to call a method rather than working on the properties : 
const obj =  { order :   function ( i,j ) {  console.log(  this.starterIndex[i] +  '  and  '  this.menuIndex[j] )  } } 
console.log( obj.order ?. ( 3 , 5 )   ? ?  " Method does n't exist " ) 


To check whether the array is empty or not : 
const users = [ {  name : 'Jatin' , email : ' thisisjatinn@gmail.com'  } ];
console.log( users[0] ? . name ??  " User Array is empty " ) 












Object.keys(object name) : to know the object keys
we know that in our hotel openingHours, we have three keys : thru,fri and sat.
for (let days of Object.keys( hotel.openingHours )  ){
  console.log( day );
}   

const properties =  Object.keys( hotel.openingHours );  --------> [ 'thru', 'fri' , ' sat '  ];



Object.values(object name) : to know the object values and not on the keys
Rather than focusing on : three keys  : thru,fri and sat, we will focus on their values : {open : 22, close : 0}...
for (let hours of Object.values( hotel.openingHours )  ){
  console.log( hours );
}   

const values =  Object.values( hotel.openingHours );  --------> [ { open : 22, close : 06 }, { . . . }, { . . .} ];



Object.entries( object na me ) : to get both, keys and the values we use entries()

const entries =  Object.entries( hotel.openingHours );  --------> [  Array(2)  ,  Array(2) ,  Array(2) ];
3 Array : [thru : obj], [ fri :obj] , [sat : obj]
of two elements each : key and value

 for ( const [ day, { open , close } ] of Object.entries ( hotel.openingHours ) ){
    console.log ( ` On $ {day }, we are open at $ { open } and close at $ { close } ` )
}











# SETs  : 
We can also work with String in here  :  new Set ( ' Jatin ' )
to know the length of an array : arr.length
to know the length of an set : set.size

to check whether some element is in an array : arr.includes( 'Pizza'  ) -----> true / false
to check whether some element is in an set : set.has( 'Pizza'  ) -----> true / false

 to add an element inside an array  : arr.push(  'Garlic Bread' );
 to add an element inside the set  :  set.add( ' Garlic Bread ' );

to remove an element from the array :  arr.pop();   ( OR )  other ways like unshift or using filter method
to remove an element from the set  : set.delete('Garlic Bread')

to make the set empty : set.clear()

Looping an set is possible : 
for( const item of set ) {  console.log( item )  } 

Converting a Set into an array : 
const removeDuplicate = [  . . . new Set ( duplicate )  ]

 to know how many unique letters are in your name;
const name = ' jatin sharma' ;
console.log(  new Set ( name ) .size )



Note : There is a Map Data structure but we will learn it later chapter  : 117











# First class function and Higher Order function  -  VERY VERY IMPORTANT !!!!

first class function : When functions are treated like any other variable. For example : a function can be passed as an argument to other functions, can be returned by another function and can be assigned as a value to a variable.

Assigning a function to a variable
const foo = () =>{ console.log('foobar') };

Passing a function as an argument
function sayHello() {  return "Hello, " ; }
function greeting ( helloMessage, name ) {  console.log( helloMessage() + name ) ;  }
greeting( sayHello , " JavaScript ! " );

// Say hello ka dusra naam he helloMessage ho gyaa hai, both are functions that is taken as argument

Returning a function 
function sayHello(){  return ()=> { console.log("Hello !"); };  }


Higher-order Functions : 
a function that receives another function as an argument, that returns a new function, or both
this is only possible because of first-class functions
 
function that receives another function : 
const greet =( ) => console.log ( ' Hey Jatin' );
btnClose.addEventListener( ' click ' , greet );  -------> here addEventListener is an higher order function

Function that returns a function : 
function count ( ) {   ----------> count is the higher order function 
  let counter = 0 ;
  return function( ) {     ------------> returns a function
   counter ++;
    }
}


Difference between both  : 
First class function  is all functions are values. There are no first class functions in practice. It's just a concept.
There are however higher order functions in practice which are possible because the langugae supports first class function.


--> nice example of higher order function : 

const oneWord = function ( str ) { 
    return str.replace( ' ', ''  ).toLowerCase();
}

const upperFirstWord = function( str ) {
    const  [ first , ...others ] = str.split( ' ' );
    return  [first.toUpperCase() , . . . others]. join ( ' ' );
}

const transformer = function ( str, fun ){
    console.log( ' Orginal String :  $ { str }' );
    console.log ( ' Transformed String : $  { fun ( str ) }  ' );
    console.log ( ' Transformed By : $ { fun.name } ' )
}

-----------------------------------------------------------------------------------
transformer( ' JavaScript is the best!', upperFirstWord )

Orginal String :  JavaScript is the best! 
Transformed String :  JAVASCRIPT is the best! 
Transformed By : upperFirstWord
 ----------------------------------------------------------------------------------
transformer( ' JavaScript is the best!', oneWord )

Orginal String :  JavaScript is the best! 
Transformed String :  javascriptisthebest! 
Transformed By : oneWord

------------------------------------------------------------------------------------

const greet = function  ( greeting ) {  return  function ( name ) { console.log( ` $ { greeting } $ { name } ` )  } ; } ;

const greeterHey = greet( 'hey' );
greeterHey( 'Jonas');
(OR)
greet( 'Hello'  )( 'World' ); 

------------------------------------------------------------------------------------












Call, Bind and apply method : 

Bind Method
const lufthansa = { 
 airline : " Lufthansa ",
 iataCode : 'LH',
 bookings : [] ,
 book( flightNum, name ) {
     console.log ( `$ { name } booked a seat on $ { this.airline } flight $ { this.iataCode }$ { flightNum } `);
     bookings.push( {  Flight : `$ { this.iataCode }$ { flightNum }`,  name } );
  }
}


lufthansa.book( 239, 'Jatin Sharma' )
lufthansa.book( 349, 'Narendra Modi ' )



const eurowings = {
 name : 'Eurowings' , 
 iataCode : 'EW',
 bookings : [],
}

// instead of writing the book method again in the eurowings will violate the DRY principle so let create a variable that store that function bcz JS has first class function: 
const book = lufthansa.book
book( 789, ' Jonas schmedtmann' ); ---------> Error bcs here this = undefined , and we want this.airline

// To use book method we will use call method : 
Syntax : book.call(  objectName , arguments  )  --------> here objectname means this will target to this object
Example : book.call( eurowings , 789 , ' Jonas schmedtmann' )


Apply method 
same as call method but only difference is it takes the arguments in the form of array like
const arrayArguments =  [  719 ,  ' Andrei neagoie ' ] 
book.apply( eurowings , arrayArguments );


Bind Method
here it returns a function which is binds to the object and you can call that function with given arguments. 
const bookEurowings = book.bind(  eurowings )
const bookLufthansa = book.bind(  lufthansa  )
const bookSwiss = book.bind(  swiss )


bookEurowings ( 832 , ' Salman Khan ' )
bookSwiss ( 912 , ' Sahid Kapoor' )
bookLufthansa ( 332 , ' Badal Chhipa ' )


 / /  You can assign this to object using bind. Now If you want to fix argument you can do that also like book takes two argument : flightNum and name and you want flightNum to be fixed as 234
const bookEurowings234 = book.bind( eurowings , 234 );
bookEurowings234 ( ' Mukesh Ambani ' )
bookEurowings234 ( ' Rajesh Khaana' )



// as we know that when we call a method that uses 'this' keyword and that is called whenever we click on some element then this targets to the Dom element.
lufthansa.planes = 300;
lufthansa.buyPlanes = function (  ){
   console.log ( this );
   this.planes++;
   console.log( this.planes )
}
document.querySelector( '#BuyButton ' ).addEventListener( ' click '  , lufthansa.buyPlanes )  -------> this gives us dom element and NaN ( this.planes )

//Now we know that we need to attack it with the object rather than dom element so we can use either call or bind but call call's the method and we don't want to call rightnow so we will go with bind that will return a new func

document.querySelector( '#BuyButton ' ).addEventListener( ' click '  , lufthansa.buyPlanes.bind( lufthansa ) )  










#Closure :  it not something that we do manually, it happens manually
const secureBooking = function( ){
 let passengerCount = 0;
 return function( ) { 
    passengerCount++;
    console.log(passengerCount ) 
   };
};

 let booker  = secureBooking( )

booker() ----> 1
booker() ----> 2
booker() ----> 3

//question is how he get the access of passengerCount as it get off from the callstack .
Ans. Closure makes a function remember all the variables that existed at the function's birthplace essentially, so we can imagine secureBooking as the birth place of return function so this return function remembers everything at its brithplace by the time it was created
Or
a function doesn't lose connection to the variables that existed at the function's birthplace
Or
a closure is like a backpack that a functions carries around wherever it goes. This backpack has all the variables that were present in the environment where the function was created 

Easy example : 
let f;
const g = function(){
 const a = 23;
 f = function() { console.log( a*2 ) }
}

g()  ------> function got assigned to f variable { a*2 } which doesn't have 'a' variable 
f()  ------->  still it return 46, this is closure






----------------------------------------------------------------------------------------------------------------------------------------------


New Day : Array Methods

#Array Methods
slice
splice : mutate the original array
reverse : mutate
concat : arr.concat( arr2 )
join : [ ' A' , ' B '  ].join(' - ' )   ----> A-B
split 
at : arr[0]  -------> arr.at( 0 ) , arr[ arr.length-1 ] -------->  arr.at(-1) , also works with string
forEach  -----> element, index  , Note ------> you cannot break out from forEachLoop
for of loop ------> for( const [ i, element  ]  of array.entries() )
Map --> creates a brand new array
filter  --> to filter an array, elements which satisfy the conditions will be inserted in the new array
reduce  --> give one value at the end, no new value
find --> same as filter but it does not return an new array but it returns only the 1st element that satisfy the condition, find return one element; where filter returns all element that fulfil his conditions; filter returns a new array but find only returns the element best to get the data like account login with the password 
findIndex  --> give the index of the found element that satisfies the condition
some  ---> papa of includes as includes only take the element but some takes the condition and returns T/F so we can say that includes is for equality and some is for condition and filter takes the input and make an array which satisfy the condition, so we only want whether the condition is satisfied by anyone or not
every  -----> when you wnt to know whthere all the elements of an array has satisfied the condition or not.  returns T/F
flat  ------>     to flat the array to one level arr.flat()    [ 1 , 2 , [ 3 , 4  ] , [  3, 4 , 5 ] ]  -->  [ 1 , 2 , 3 , 4  ,3 ,4 , 5  ].
 arr.flat(levelNumber)
flatMap  ---> flat( at last it flats the map result) + map (1st ); Note -----It only goes one level deep
sort --> for strings is simple, for number is different  , a-b : ascending, b-a descending
Total 23 methods 



-----If you want to add an html element from javascript into some container, use insertAdjacentHTML
How ? 

DOM_ELEMENT. insertAdjacentHTML (  position :   'afterbegin' / 'afterend' / 'beforebegin' / ' beforeend ', element you want to insert )

let html = `<div>As per you want</div>`
document.querySelector( ' .movements').insertAdjacentHTML (  afterbegin, html  ) 




For login auth and checking whether thee account is there or not  : find
For deleting an account we can use of : findIndex
For taking an loan that check certain things whether they are satisfied or not of the current account :  some  
For knowing whether all the elements satisfies the condition or not  : every
For removing arrays from nested loop like [  1 ,2 [ 3, [  432 ] , 5 ] ,[3 ,5 ] ] to one arrray : flat


Q . how to know which method should i use ?
Ans 
To mutate the original array
push end mai add karne k liye
unshift start mai add karne k liye
pop end se nikalne k liye
shift starting se nikalne k liye
splice  koi bhi element ko nikalne k liye
reverse  reverse karne k liye
sort  sort strings or numbers elements
fill  array mai elements dalne k liye


A new array
map iterate karne k liye
filter  filter karne k liye wohi element honge jo condition fulfil karenge
slice without argument apne ko copy of array return karega and args diye honge to remove karke dega
concat do array ko combine karke array dega
flat flat karne k liye nested arrays ko, by default 1 level he but we can specify the number of levels
flatMap  mixer of flat and map jisme map phele run hota hai or uske result ko baadme flat karte hai


Do i maybe want an array index
indexOf based on value dhundega
findIndex  based on test conditions dhundega

Or do i want to retrieve an entire array element
find to get the array itself based on some condition

Or do i want to know whether an array includes 
includes based on value, checks for equality 
some  based on some condition, returns T / F , ek bhi true element mila toh T warna F
every   based on some condition, returns T / F , sare T honge toh he true milega warna F

Or maybe i want a new string
join sare elements ko join kardega or ek string bana dega

Or to transform an array to a new value
reduce boils down to one value, isme ek accumulaot hota hai final variable jesa

Or simply to loop over the array
forEach 

Total  : 23 Methods


----------------------------------------------------------------------------------------------------------------------------------------------



Next Day  : Numeric separator




To convert a String into Number : 
Number('23')
+'23'

#To get the Number from a String which starts from a number like '23px'  use : parseInt
Number.parseInt('23px')  --->23
Number.parseInt('px23')  --->NaN

Number.parseFloat('2.3rem')  --->2.3
Number.parseInt('2.3rem')  --->2

#to check whether the number is number or not
console.log(Number.isFinite('20')) -----> false
console.log(Number.isFinite(20)) -----> true

# to know the square root of a number :
console.log(Math.sqrt(25)) -----> 5

# to know the maximu out of some numbers :
console.log(Math.max(1,4,2,5,23,19)) -----> 23
console.log(Math.max(1,4,2,5,'23',19)) -----> 23
console.log(Math.max(1,4,2,5,'23px',19)) -----> NaN


# to generate  random number:
Math.trunc( Math.random() * 6 ) + 1

#to remove decimal part : trunc 
Math.trunc(234.8678) ------> 234

#to get the round figure : 
Math.round(23.7) ----> 24
Math.round(23.3) ----> 23
Math.round(23.5) ----> 24


#to get the higher figure : 
Math.ceil(23.7) ----> 24
Math.ceil(23.3) ----> 24
Math.ceil(23.5) ----> 24

#to get the lower figure : ( all do type coersion ) 
Math.floor(23.7) ----> 23
Math.floor(23.3) ----> 23
Math.floor(23.5) ----> 23

Math.floor(-24.4) -------> -25
Math.trunc(-24.4) -------> -24



#If the number is very big and you want to write it into good & readable format, use underscore :
const diameter = 287_460_000_000;
console.log(diameter)  ------>287460000000

const price = 55_21;
console.log(price)   -----> 5521

Rules : 
can't use two underscore together
can't use it in the starting or ending of the number
can't use it right after dot ( . )
if there is a string '23000' you can convert it into number but if there is an underscore you can't convert it into number using Number('23_000') --> NaN
parseInt('23_000')-----> 23 and not 23000



Note : you will get a nodeList when you use document.querySelectorAll('.row'), so to make it an array :   [ . . . document.quersySelectorAll('.row')  ]











#Big Int 

Numbers are represented internally as 64bits means there are exactly 64 ones or zeros to represent any given number and out of these 64 bits only 53 are used to actually store the digits themselves the rest are storing the decimal points and the sign

If there are only 53 bits to store the number that means that there is a limit so the biggest number is
( 2 ** 53 - 1 )  = 9007199254740991     
-1 is because the number starts from 0

This is stored as an global variable in Number.  console.log( Number.MAX_SAFE_INTEGER )

After this number, Js won't give us an accurate answer 

For using Big Intgers you can use the Type BigInt(number) or add 'n' in the end of the large number :
console.log( BigInt ( 765456782653273273277 )  )
OR
console.log( 92783872832937264283n ) 

BigInt also works the same like 2000n + 1000n = 3000n  
But you can't mix BigInt with normal integers  : 2000n * 3  = Erro 
but you can work like comparsion between both : 2000n > 5   = true








#SetTimeOut and SetInterval

Syntax : setTimeout( ( parameters) = >  {   } , time , arguments )
Example :  setTimeOut(  ( ing1 , ing2 ) => {  console.log( ` your pizza with $ { ing1 } and $ { ing2 } is on the way!!  ` ) } , 500 , 'olives' , 'spinach'   )


You can stop the interval / timer too using clearTimeout( setTimeout(Name) )
const ingredients = [  ' olives ' ,  '  spinach ' ];
const pizzaTimer = setTimeout( ( ing1 , ing2 ) => { console.log( ` your pizza with $ { ing1 } and $ { ing2 } is on the way!!  } , 2000 , . . . ingredients )
if( ingredients.includes( ' spinach ' ) clearTimeout( pizzaTimer ) )

-So if there is spinach in the ingredients array , we will nott get the message from the setTimeout but if there is no spinach we will get the output without calling the pizzaTimer



We use the setTimeout when we want to do things which should take some time to happen and happen only once.
while in setInterval we do things that should keep going and going like a clock
same syntax and example

Time : // 
let time = 100 // 100 seconds countdown
const clockTimer = setInterval (  ( ) => {

  //  but this will give us some ugly decimal numbers
   const min = time / 60;     -----> 1
   const sec = time % 60;    ----> 40
  
  // So will use trunc to remove ugly part and use padStart to show "1:5" as "01 : 05"
   const min = String( Number.trunc ( time / 60 ) ) . padStart( 2 , '0' )  ;     -----> "01"
   const sec = String ( Number.trunc ( time % 60 ) ) .padStart(  2 , '0' ) ;    ----> "40"

   time--; 
   
   // to stop the timer when the time reachs 0
    if ( time == 0 ){
        clearInterval( clockTimer )
     }

}  , 1000 );



----------------------------------------------------------------------------------------------------------------------------------------------
