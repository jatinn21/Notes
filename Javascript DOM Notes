Javascript DOM Notes : Section -> 13

DOM concept 

//Selecting Element(s)
NodeList :   document.querySelectorAll(' .submitBtn ')
It's not live

HTMLCollection : document.getElementsByTagName('button') or ByClassName
It's live means if you will delete any element than the HTML collection will also reflect



// Creating and inserting elements 
const message = document.createElement('div');

// add class to the element
message.classlist.add('cookie-message');

// add text to the element
message.textContent = 'We use cookies for improved functionality and analytics'
(OR)
message.innerHTML = `We use cookies for improved functionality and analytics <button class='btn-close'>Ok, Got it</button>` 

// now show that in our website
const parentContainer = document.querySelector('#fullscreen')
parentContainer.prepend(message)
- the newly created will be now our first child in the fullscreen element

parentContainer.append(message)
- the newly created will be now our last child in the fullscreen element

Note :  It can't be at multiple places by using append & prepend both

Note : append & prepend will bring the created element inside the 'parentContainer' body

before(message)  
this will  bring the created element before the parentContainer , outside it and before it

aftere(message)
this will  bring the created element after the parentContainer , outside it and after it


//Remove an element
element.remove()
document.querySelector('.cookie-message').addEventListener( 'click' , ()=> { message.remove()  } )


//-------------Styles-----------
getComputedStyle(element) 

To know the styles of some element we can't get it directly using :
 console.log(message.style.height)
To get we can use getComputedStyle() :
 console.log( getComputedStyle( message ) )  ------> object of style like , height,width,bgcolor,color....
 //to get the specific property value : 
console.log ( getComputedStyle( message ).height )

//to know a custom attribute value that is created by us and not by html
const logo = document.querySelector(#logo);
<img id='logo'  alt =''logoCompany' src='https://www.logo.com'  designer=''Jonas''/>
console.log(logo.alt)   --> will print the value
console.log(logo.src)   --> will print the value
- console.log(logo.designer)   --> will print undefined 
--> to print : console.log( logo.getAtrribute('designer') );    ---> "Jonas" 

//to set an attribute 
logo.setAttribute( 'company','bankist minimalist logo' )


// data Attribute
<img id='logo'  alt =''logoCompany' src='https://www.logo.com'  designer=''Jonas' data-version-number= '3.0'/>
console.log(logo.dataset.versionNumber);


// classes
logo.classlist.add('c' , 'j')
logo.classlist.remove('c', 'j')
logo.classlist.toggle('c')
logo.classlist.contains('c')





------------------------------------------------------------------------------------------------------------------
next day


//smooth scrolling

const btnScrollTo = document.querySelector('.btn-scroll-to');    // clicking this button will make scrolling
const section1 = document.querySelector('#section--1');        // section we wnt to see when we click the btn

btnScrollTo.addEventListener( ' click ' , (event)=>{
   //select the section you want to scrolled to then apply .scrollIntoView method which takes an object with behavior attribute to 'smooth'

  section1.scrollIntoView( { behavior : 'smooth' } )    // it works
})




// types of events
to add event we use .addEventListener('click',alertMsg)
to remove event we use  .removeEventListener('click',alertMsg)

like : 
const h1 = document.querySelector('h1');
const alertMsg =  function( )  {  
   alert(' You are reading the headline as you have your mouse over the heading !!');
   h1.removeEventListener('mouseenter', alertMsg )
 }

h1.addEventListener('mouseenter' , alertMsg )




// bubbling and capturing

document >html > body > section > p > a.link

Suppose the click element happens, we know that our click event will right generates, so that event is actually not generated at the target element, but it generates in the root of the document i.e very top of the DOM element.
From there, the so-called capturing phase happens,  where the event then travels all the way down to the target element and it will pass to every parent element i.e html --> body --> section --> p --> a.link ( target element )

As soon as the event reaches the target, target phase begins, where events can be handled right at the target using Event Listeners and then the attach function is executed and this all happens in the target phase.

After reaching the target, the event then travels all the way up to the document route again : 
a.link  --> p --> section --> body --> html --> document 
this is called bubbling phase

To understand well : check udemy 191 video , Amazing example 
to stop propogation : e.stopPropagation()





// Trick for scrolling to different link sections as per the link
multiple links like about (#section--1), contact ( #section--2 ) ,features  ( #section--3 ) having same class = 'nav-links'

//Scroll to the respected section
const allLinks = document.querySelectorAll('.nav__link');
allLinks.forEach(ele => {
  ele.addEventListener('click', e => {
    e.preventDefault();
    const id = ele.getAttribute('href');
    document.querySelector(id).scrollIntoView({ behavior: 'smooth' });
  });
});



// Above we are attaching the same function to all 3 elements, which is handy for now but what if we have 1000s of links elements? then it might reduce our application performance...
for that, we will use event delegation, where the parent's function i.e ( ' .nav__links'  ) is used by the child elements  ( ' .nav__link ') 
Approach :
 1. Add event listener to common parent element
 2. Determine what element originated the event
 3. Avoid other clicks events, only click to links should be take into consideration

document.querySelector('.nav__links').addEventListener('click', e => {
  e.preventDefault();
  if (e.target.classList.contains('nav__link')) {
    const id = e.target.getAttribute('href');
    document.querySelector(id).scrollIntoView({ behavior: 'smooth' });
  }
});







-------------------------------------------------------------------------------------------------------------------------
Dom traversing

How to generate a random color : 
const randomColor = (min,max) => { 
 const colorCode = Math.floor(   Math.random() * (min-max +1 )  + min );
 return colorCode;
 }

const color = () => `rgb(${ randomColor(0,255) , ${ randomColor(0,255) , ${ randomColor(0,255)   })`
  color = rgb(123,38,93)

<html>
   <body>
            <div class='grandparent' id='grandparrent-id'>
                       <div class='parent'>
                                  <div clas='child' id='child-one' ></div>
                                  <div clas='child' id='child-two'></div>
                        </div>
                        <div class='parent'>
                                  <div clas='child'></div>
                                  <div clas='child'></div>
                        </div>
            </div>
    </body>
</html>



Tips and tricks :  
selecting elemet by id : 

const grandparent = document.getElementById('grandparent-id')
function changeColor( element ) {  
      element.style.backgroundColor = '#333';
}
changeColor( grandparent ); 

selecting elements by classname

const parents = document.getElementsByClassName('parent')   ----> this will return an collection and we can't use forEach with collection
// so make it an array

const parents = Array.from(document.getElementsByClassName( 'parent' ))
parents.forEach( ( element )  => changeColor(element))


//  if you are using querySelectorAll then we don't have to make an Array.from( ) 


children keyword :  used to get the children elements of that element, it will return html collection so nonproblem but you can't use forEach so use Array.from(htmlcollection)

const grandparent = document.querySelector('.grandparend');
const parents = Array.from ( grandparent.children )
parents.forEach( ( element) => changeColor(element)  )     //only parent element's color will be change and not child


const parentOne = parents[0]
const children = parentOne.children

changeColor(children[0])     // first parents first child's color will be changed

// So till yet we understood how to go down the DOM, lets' go up from the bottom
const childOne = document.querySelector('#child-one');
changeColor(childOne)

//So to select the parent element use .parentElement
const parent = childOne.parentElement
changeColor(parent)    ----> 1st parent color will be changed

// to change the color of grandparent element
const grandparent = parent.parentElement
changeColor(grandparent)


// what if you don't want to touch the parent from the child and want to call grandparent without callling parent element?
//We will use .closest
const childOne = document.querySelector('#child-one');
const grandparent = childOne.closest(' .grandparent ')

--closest works very similar to querySelectore except for it moves upwards instead of moving downwards, so you can pass it a selector in our case, our grandparent has the class of grandparent and what closest does is it select the closest parent element that has this selector

-- so now we know how to go down the DOM , up the down, now we will learn how to go side by side means : going through siblings like in parentOne there are 2 child and we have selected the child one of parentOne and we want to access childtwo of the parentOne that means childOne and childTwo are sibling and we want to access one sibling from another, for that we will use nextElementSibling
 
const childOne = document.querySelector('#child-one');
const childTwo = childOne.nextElementSibling
changeColor(childTwo)  ----> now the color of child two of parentOne will be changed

//if you want to move from child two to child one, use previousElementSibling
const childTwo = documet.querySelector('#child-two');
const childOne = childTwo.previousElementSibling
changeColor(childOne)



// we also have firstElementChild, lastElementChild, as the name suggest what they do so no more description on that.





  




