The Goal of Asynchronous Js is to basically deal with long-running tasks, that run in the background. 
The most common use case is to fetch data from remote servers, in so-called AJAX Calls where AJAX: Asynchronous Javascript and XML
We are gonna learn about :
i. Promises
ii. fetch function
iii. async await
iv. Error handling

---------------------------------------------------------------------------------------------------------------------------------
About and Use of AJ - Asynchronous Javascript
----------------------------------------------------------------------------------------------------------------------------------
Most of the code that we have written so far is synchronous code, which means the code is executed line by line.
Each line of code waits for the previous line to finish;

Problem: Long-running operations block code execution;

Remember: call stack, Web APIs, and callback queue.

Best Example: alert()

Best Code : 
const p = document.querySelector('.p');
p.textContent = 'My Name is Jatin';
alert('Text Set!');
p.style.color = 'red';

Result :
Here things like a change of text and color happen after the alert 'ok' click event happens. This means blocking of the code can be seen 

Synchonous is great when you want things to go in order but imagine when execution has to wait for like 5 seconds then that would be terrible, Right?
Meanwhile, nothing on the page will work during these 5 seconds, and there where asynchronous code coming into play.

Code :
const p = document.querySelector('.p');
setTimeout(function(){
    p.textContent = 'Hello World';
},5000)
p.style.color = 'red';

Result :
here there is nothing synchronous, so no blocking, first the color of the element will be changed, and then the content after 5 sec.

Another Code Example :
// setting Image with load event listener 
// src in image makes our code async here
const img = document.querySelector('.dog');
img.src = 'dog.jpg';
img.addEventListener('load',function(){
    img.classlist.add('fadeIn');
});
p.style.width = '400px';

Note: addEventListener does not automatically make the code asynchronous!! so do callback functions!!







# AJAX
It stands for Asynchronous Javascript and XML, allowing us to communicate with remote web servers in an asynchronous way. With AJAX calls, we can request data from web servers dynamically.
Example :
Create an application that will show Country info by taking the name from the user.
Here the client will send the request(country info by sending the country name) and the server will send the response.
We handle all these responses using AJAX. We use the API concept for fetching the data of the country

#API
Application Programming Interface, to a very high level of abstraction we can define it as a piece of software that can be used by another piece of software, in order to allow applications to talk to each other. 
There are many types of APIs in web development like DOMAPI, and Geolocation API.
Also, you can always implement a small and simple API in a class, where we make some methods available as a public interface. So again object made from a class can be seen as a self-contained encapsulated piece of software that other pieces of software can interact with. 

Online API : 
An application running on a server, that receives requests for data, and sends data back as a response. we call that 'API'.
We have APIs for everything: Weather data, data about countries, Flight data, currency conversion data, APIs for sending email or SMS, Google Maps, and other millions of possibilities with APIs.


#API data formats :
--> AJAX: Asynchronous Javascript and XML, where X stands for XML and XML is a data format that is widely used to transmit data on the web. However, no API uses XML data anymore but as this AJAX word starts gaining popularity even knowing that XML is not used anymore.
So instead, Most APIs these days use the JSON data format, very popular today, as it's a Javascript object but converted into a string and that's why it's easy to send on the web and use in Javascript once the data arrives.





//most old-school way of doing AJAX calls

BTS : 
we got a repo on Git Hub named 'public-apis' and there are three things mentioned about various types of APIs i.e. Authorizations, CORS, and HTTPS.
Remember: Using 3rd party API, we need CORS, Cross-origin-resource-sharing.
Best API for countries info: restcountries.com, endpoints mai jaake 

#Our First AJAX call: XMLHttpRequest 
AJAX call Code : 
const request = new XMLHttpRequest();
request.open('GET','https://restcountries.com/v2/name/india');
request.send();   //This will take time to fetch data so once it is over we will listen to it using the event listener
console.log(request.responseText);
request.addEventListener('load',function(){
    console.log(this.responseText); // this === request;
});

Remember: We get a string in the result because what we have is JSON, so we have to convert it into a good-looking and more readable output
const output_Data = JSON.parse(this.responseText);   --> Now we have an Array of one Object as we have only one country info 

We can then make an HTML element that will change the info as per the county info and can insert it in the DOM using insertAdjacentHTML(position, HTML)

The best way is to make a function that will take the country name as an argument and will make the AJAX calls, make the element, and insert it in the DOM. Wowwwwwww!


Final Code :
function getCountryData(countryName){
  const request = new XMLHttpRequest();
  request.open('GET',`https://restcountries.com/v3.1/name/${countryName}`);
  request.send();
  request.addEventListener('load',function(){
        const data = JSON.parse(this.responseText);
        const html = `<div>
                          <p>
                            <img src=`data.flag`>
                          <p>
                          <p>  
                            <span>
                                Country Name :
                            </span>  
                            <span>
                                ${data.name}
                            </span>
                          </p>
                          <p>
                            <span>
                                 Country Population 
                            </span>
                            <span>
                                ${ (+data.population/1000000).toFixed(1) Million people}
                            </span>
                          </p>   
                          <p>
                            <span>
                                 Region 
                            </span>
                            <span>
                                ${ data.region }
                            </span>
                          </p>   
                      </div>`;
         document.querySelector('.contentContainer').insertAdjacentHTML('beforeend',html);
         document.querySelector('.contentContainer').style.opacity = '1';
});
}


getCountryData('india');
getCountryData('usa');
getCountryData('uk'); 

Remember: it might happen that the data of India gets fetched first and then uk and at last the USA so things will be placed as per that only depends on which data arrives first. this shows us the non-blocking behavior of Javascript using AJAX calls.
You can't say in which order, the data will appear.

If you want to have a predefined order in which they should appear, then we have to make a chain the requests, which means making a second request only when the first request is completed/finished. and this gives rise to "CALLBACK HELL"





-----------------------------------------------------------------------------------
How the Web Works Behind the Scenes
-----------------------------------------------------------------------------------
we have a client(browser) and a web server
brief explanation: 
client or the browser sends a request to a web server and the webserver then sends a response back to the browser. That Response can be the data or the web page that was requested. this is called request-response modal or client-server architecture.

Deeper knowledge :
let's take the example of the URL we used for getting countries' info
https://restcountries.com/v3.1/name/india
  Here, 
i.  Protocol: 'https' is a protocol here, one more is HTTP & every URL gets an HTTP or HTTPS that will be used on this connection
ii. Domain-name: 'restcountries.com' is the domain name
iii. Resources: '/v3.1/name/India' is the resource that we want to access.

This domain name is not the real address of the server that we're trying to access. It's really just a nice name given to us to easily memorize it. 
This means that we need to convert this domain name into the real address of the server and that happens through a so-called DNS (Domain Name Server).
DNS is a special kind of Server, So they are basically like the phone books of the internet.

So the first step that happens when we access any Web Server is that the browser makes a request to a DNS and this special server will simply match the web address of the URL to the server's real IP address, all right. and this all happens through your Internet Service provider but the complete details don't matter here.
So DNS converts the Domain into a real IP address and then sends the Real IP address to the browser, we can finally call it.
https://restcountries.com/v3.1/name/   -------------------> https://104.27.142.889/443
Domain --> IP address, where 104.27.142.889 is the IP address, and 443 is the PORT NUMBER, default is 443 for HTTPS

The port number is just to identify a specific service that running on the server. (like a subaddress)
Plus this port number has nothing to do with the 'v3.1/name/india' resource that we want to access.
That info is sent over in the HTTP request

So That actually wraps up the first step!!!!!!!

So once we have the real IP address, a TCP/IP socket connection is established between the browser and the server and so they are now finally connected. this connection is kept alive for the entire time that it takes to transfer all the files of the website or all data.

so TCP is Transmission Control Protocol & IP is Internet Protocol & Together they are communication protocols that define exactly how data travels across the Web. Or call them Internet Fundamental Control Systems, because they are the ones who set the rules about how data moves on the internet.

Now, let's make our request!!
and the request that we make is an HTTP request where HTTP is HyperText Transfer Protocol.
So After TCP/IP, HTTP is another communication protocol that is simply a system of rules that allows two or more parties to communicate.
In HTTP, it's just a protocol that allows clients and Web Servers to communicate and that works by sending request and response messages from client to server and back.

The Request message looks like this :
GET /v3.1/name/India HTTP/1.1
Host: www.google.com
User-Agent: Mozilla/5.0
Accept-Language: en-US

<BODY>


The Starting line of the message is HTTP method + request target + HTTP version  
The most important HTTP methods are :
i. GET, for simply requesting data
ii POST, for sending data
iii. PUT & PATCH, for modifying data

Request target is what we told the server we want to access, in this case, we told it to access the 'v3.1/name/India' resource.
this was in our URL but now it was sent as a HTTP target request.

after this, the next line of the request is the request headers, which are just some info that we send about the request itself.
There are tons of standard different headers like what browser is used to make the request, at what time, the user's language, and many more.

Now, finally, in case of sending data to the server, there will also be a request body and that body will contain the data that we're sending, for example, coming from an HTML Form, so that's the HTTP request.

The main difference between HTTP and HTTPS is HTTPS is encrypted using TLS or SSL, which are still some protocols. but besides that, the logic behind HTTP requests and responses still applies to HTTPS.

so our request is formed and now it hits the server, which will then be working on it until it has our data or Webpage ready to send back and once it's ready, it will send back using HTTP response.
and HTTP response looks like this:
HTTP/1.1 200 OK
Date: Mon, 27 Nov 2023
Content-Type: text/HTML
Transfer-Encoding: chunked

<BODY>

the first line includes the HTTP version and the status code like 200 says the request was sent successfully and a 404 page is not found
The body contains the JSON data

TCP is to break the requests and responses down into thousands of small chunks called packets before they are sent. Once the small packets arrive at their final destination, TCP will reassemble all the packets into the original request or response and this is necessary so that each packet can take a different route through the internet because this way the message arrives at the destination as quickly as possible which could not be possible if we send all the packets using one same path as it would create a huge traffic.
Now here comes the IP, and its job is to actually send and route these packets through the internet so it ensures that they arrive at the destination they should go using the IP address on each packet




------------------------------------------------------------------------------------
Welcome to Callback Hells
------------------------------------------------------------------------------------

This callback hells happens when you try to execute multiple asynchronous operations in sequence. This leads to nesting callbacks and creates a callback hell which makes our code less readable/hard to maintain and debug.

simple callback hell :
setTimeout(()=>{
    console.log('1 second passed!');
    setTimeout(()=>{
        console.log('2 second passed!');
          setTimeout(()=>{
            console.log('3 second passed!');
                setTimeout(()=>{
                    console.log('4 second passed!');
                },1000)
          },1000)
    },1000)
},1000)


--------------
country callback hell example :

let borders;
const renderCountry = function (data, className = '') {
  const html = `
  <article class="country ${className}">
    <img class="country__img" src="${data.flags.svg}" />
    <div class="country__data">
      <h3 class="country__name">${data.name.common}</h3>
      <h3 class="country__region">CAPITAL : ${data.capital}</h3>
      <h4 class="country__region">REGION : ${data.region}</h4>
      <p class="country__row"><span>POP</span>${(
        data.population / 1000000
      ).toFixed(1)}M people</p>
      <p class="country__row">BORDER : <span></span>${borders?.join(',')}</p>
      
    </div>
  </article>`;
  countriesContainer.insertAdjacentHTML('beforebegin', html);
  countriesContainer.style.opacity = '1';
};

const countryAndNeighbour = function (country) {
  const request = new XMLHttpRequest();
  request.open('GET', `https://restcountries.com/v3.1/name/${country}`);
  request.send();
  request.addEventListener('load', function () {
    const [data] = JSON.parse(this.responseText);
    console.log(data);
    let countryCode = data.fifa?.toLowerCase();
    borders = data?.borders;
    renderCountry(data);

    const request2 = new XMLHttpRequest();
    request2.open('GET', `https://restcountries.com/v3.1/alpha/${borders[0]}`);
    request2.send();
    request2.addEventListener('load', function () {
      const data2 = JSON.parse(this.responseText);
      console.log(data2);
      renderCountry(data2, 'neighbour');
    });
  });
};

// countryAndNeighbour('bharat');
// countryAndNeighbour('portugal');
countryAndNeighbour('uk');
// countryAndNeighbour('germany');



Solution for callback hells : 
Javascript has come up with something called PROMISES in ES6, 2015.

Let's Learn That in the next session...




------------------------------------------------------------------------------------------
PROMISES
------------------------------------------------------------------------------------------
The promise is a Javascript Object that is a placeholder for storing the future result(future responses coming from AJAX calls) of an asynchronous operation. 

Here we don't go with the Old-school way of AJAX calls i.e XMLHttpRequest()
we use fetch('url') that returns us a promise immediately.

const request = fetch('https://restcountries.com/v3.1/name/bharat');
console.log(request); -----> Promise{pending}

PROMISE LIFECYCLE : 
whenever we create a promise, that promise goes inside the "pending" state which means the asynchronous work is not yet done.
once the work is done we are in the "fulfilled" Phase, which still has two categories : 
i. Rejected: there is some error while performing the request.
ii. Solved: the asynchronous work has been done without any problem as we have expected. example : 
while making an AJAX call to get the data using API, the user went offline and is not connected to API server.   

Promise only settled once, and when it is settled then the state can't be changed forever.

Main Benefit :
i. We don't have to rely on events and callbacks to handle asynchronous results.
ii. Plus to make our asynchronous operations go in a sequence, we don't have to make nested callbacks so we are safe from callback hells.

Consume Promise :
when we already have a promise. EG. promise returned from fetch API

Build Promise :
fetch API returns the promise, so we don't have to build promise by ourselves.


Example : 
// FETCH API
const country = function (countryName) {
  fetch(`https://restcountries.com/v3.1/name/${countryName}`)
    .then(function (response) {
      return response.json();   
    })
    .then(function (data) {
      console.log(data);  ---> [Portugal data]
    });
};

country('portugal');
NOTE : 
we have used response.json because when we get something from the response from the fetch, we are more into the data that comes in a readable stream which we can't see. So to see that data we use json method which is available on all responses of the fetch method, so to see the data we used response.json().
The problem is that this json method is itself an asynchronous function. so that means it will also return a new promise. This is all confusing but that's how it works!!
So we have to return the json method can handle it in returned promsie using "then"


SUMMARY : 
fetch will return a promise --> handle using then() --> using a function inside that then method and that function will take a response ---> that response will be in readable stream which can't be read from the body ---> to make it read we will use json method, which is a asynchronous function and so it will return a new promise so do return response.json() so that you can handle this in new promise ----> new then() which will take a new function and that function will take an parameter say data and that data is what we want, the country info so now you can render the country in your html.  

Simple code using arrow function :
const country = function (countryName) {
  fetch(`https://restcountries.com/v3.1/name/${countryName}`)
    .then(response => response.json())
    .then(data => console.log(data))
};

Note: we are still using callbacks, so we get rid of callback hells but not from callbacks functions.

To make multiple request or asynchronous operations in a sequence we can use Promises:
const country = function (countryName) {
  fetch(`https://restcountries.com/v3.1/name/${countryName}`)
    .then(response => response.json())
    .then(data => {
            renderCountry(data);
            const neighbour = data.borders?.[0];

            if(!neighbour) return;
            return fetch( `https://restcountries.com/v3.1/alpha/${neighbour}`);    ----> twist point
    })
    .then(response2 => response2.json() )
    .then(data2 => renderCountry(data2,'neighbour'));
};

REMEMBER :
on twist point, fetch will again give us a new promise so we can start doing the same process of doing chaining there inside that block, like a normal guy thinks, but this will again bring callback hell into our code, So don't be try to be damn smart. Work on One task, take the work in then chain() 



Note : 
then( response => {
    return 23;
     })
.then( data => console.log(data));  ----------> data = 23


------------------------------------------------------------
To handle Error: like cannot connect to API Server
------------------------------------------------------------
then() handles all the fulfilled promises and catch() handles all the error no matter what's the error


//Most recommended when you don't know where the error happens in which promise!!
TYPE1 using catch() , CODE EXAMPLE :
const country = function (countryName) {
  fetch(`https://restcountries.com/v3.1/name/${countryName}`)
    .then(response => response.json())
    .then(data => {
            renderCountry(data);
            const neighbour = data.borders?.[0];

            if(!neighbour) return;
            return fetch( `https://restcountries.com/v3.1/alpha/${neighbour}`);
    })
    .then(response2 => response2.json() )
    .then(data2 => renderCountry(data2,'neighbour'))
    .catch(error => alert(error))   /////////////////////////////////////////////////   <--------------------Check on this line
    .catch(error => renderError('Error Occurred'))   /////////////////////////////////////////////////   <--------------------Or render the error on the screen in a text form

};



we can also handle the error in then method, it takes two argument function, first is the fulfilled of course, and second one is optional i.e  error handling, separated by ','


TYPE2 using then() , when you know where the error occurs , CODE EXAMPLE :
fetch(`https://restcountries.com/v3.1/name/${countryName}`)
.then(response=> response.json()
        ,
       error => console.log(error))



and At last we have "finally", catch only works when we have got some error, then only works when we have some fulfilled response, finally is called everytime no matter there is an error or not, it is not usefull always as it is called everytime and we use this at the end of the chaining



Finally CODE EXAMPLE :
  fetch(`https://restcountries.com/v3.1/name/${countryName}`)
    .then(response => response.json())
    .then(data => {
            renderCountry(data);
            const neighbour = data.borders?.[0];

            if(!neighbour) return;
            return fetch( `https://restcountries.com/v3.1/alpha/${neighbour}`);
    })
    .then(response2 => response2.json() )
    .then(data2 => renderCountry(data2,'neighbour'))
    .catch(error => alert(error))
    .finally(()=>{
        console.log('this block will always be executed');
    })

